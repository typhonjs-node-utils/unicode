{"version":3,"file":"index.js","sources":["../../src/unicode-trie/Constants.ts","../../src/unicode-trie/Swap32LE.ts","../../src/unicode-trie/UnicodeTrie.ts","../../src/unicode-trie/UnicodeTrieBuilder.ts"],"sourcesContent":["/**\r\n * Shared constants between {@link UnicodeTrie} and {@link UnicodeTrieBuilder}.\r\n */\r\nexport class Const\r\n{\r\n   static readonly SHIFT_1: number = 6 + 5;\r\n\r\n   /**\r\n    * Shift size for getting the index-2 table offset.\r\n    */\r\n   static readonly SHIFT_2: number = 5;\r\n\r\n   /**\r\n    * Difference between the two shift sizes, for getting an index-1 offset from an index-2 offset. `6=11-5`.\r\n    */\r\n   static readonly SHIFT_1_2: number = this.SHIFT_1 - this.SHIFT_2;\r\n\r\n   /**\r\n    * Number of index-1 entries for the BMP. `32=0x20`.\r\n    * This part of the index-1 table is omitted from the serialized form.\r\n    */\r\n   static readonly OMITTED_BMP_INDEX_1_LENGTH: number = 0x10000 >> this.SHIFT_1;\r\n\r\n   /**\r\n    * Number of entries in an index-2 block. `64=0x40`.\r\n    */\r\n   static readonly INDEX_2_BLOCK_LENGTH: number = 1 << this.SHIFT_1_2;\r\n\r\n   /**\r\n    * Mask for getting the lower bits for the in-index-2-block offset.\r\n    */\r\n   static readonly INDEX_2_MASK: number = this.INDEX_2_BLOCK_LENGTH - 1;\r\n\r\n   /**\r\n    * Shift size for shifting left the index array values.\r\n    * Increases possible data size with 16-bit index values at the cost of \"compactability\".\r\n    * This requires data blocks to be aligned by #DATA_GRANULARITY.\r\n    */\r\n   static readonly INDEX_SHIFT: number = 2;\r\n\r\n   /**\r\n    * Number of entries in a data block. `32=0x20`.\r\n    */\r\n   static readonly DATA_BLOCK_LENGTH: number = 1 << this.SHIFT_2;\r\n\r\n   /**\r\n    * Mask for getting the lower bits for the in-data-block offset.\r\n    */\r\n   static readonly DATA_MASK: number = this.DATA_BLOCK_LENGTH - 1;\r\n\r\n   /**\r\n    * The part of the index-2 table for U+D800..U+DBFF stores values for lead surrogate code _units_ not code _points_.\r\n    * Values for lead surrogate code _points_ are indexed with this portion of the table.\r\n    * Length=32=0x20=0x400>>SHIFT_2. (There are 1024=0x400 lead surrogates.)\r\n    */\r\n   static readonly LSCP_INDEX_2_OFFSET: number = 0x10000 >> this.SHIFT_2;\r\n   static readonly LSCP_INDEX_2_LENGTH: number = 0x400 >> this.SHIFT_2;\r\n\r\n   /**\r\n    * Count the lengths of both BMP pieces. `2080=0x820`.\r\n    */\r\n   static readonly INDEX_2_BMP_LENGTH: number = this.LSCP_INDEX_2_OFFSET + this.LSCP_INDEX_2_LENGTH;\r\n\r\n   /**\r\n    * The 2-byte UTF-8 version of the index-2 table follows at offset `2080=0x820`.\r\n    * Length `32=0x20` for lead bytes `C0..DF`, regardless of SHIFT_2.\r\n    */\r\n   static readonly UTF8_2B_INDEX_2_OFFSET: number = this.INDEX_2_BMP_LENGTH;\r\n   static readonly UTF8_2B_INDEX_2_LENGTH: number = 0x800 >> 6;  // U+0800 is the first code point after 2-byte UTF-8\r\n\r\n   /**\r\n    * The index-1 table, only used for supplementary code points, at offset `2112=0x840`.\r\n    * Variable length, for code points up to highStart, where the last single-value range starts.\r\n    * Maximum length 512=0x200=0x100000>>SHIFT_1.\r\n    * (For 0x100000 supplementary code points U+10000..U+10ffff.)\r\n    *\r\n    * The part of the index-2 table for supplementary code points starts after this index-1 table.\r\n    *\r\n    * Both the index-1 table and the following part of the index-2 table are omitted completely if there is only BMP\r\n    * data.\r\n    */\r\n   static readonly INDEX_1_OFFSET: number = this.UTF8_2B_INDEX_2_OFFSET + this.UTF8_2B_INDEX_2_LENGTH;\r\n   static readonly MAX_INDEX_1_LENGTH = 0x100000 >> this.SHIFT_1;\r\n\r\n   /**\r\n    * The alignment size of a data block. Also, the granularity for compaction.\r\n    */\r\n   static readonly DATA_GRANULARITY: number = 1 << this.INDEX_SHIFT;\r\n}\r\n\r\n/**\r\n * Constants specific to {@link UnicodeTrieBuilder}.\r\n */\r\nexport class ConstB\r\n{\r\n   /**\r\n    * Number of code points per index-1 table entry. `2048=0x800`.\r\n    */\r\n   static readonly CP_PER_INDEX_1_ENTRY = 1 << Const.SHIFT_1;\r\n\r\n   /**\r\n    * The BMP part of the index-2 table is fixed and linear and starts at offset 0.\r\n    * Length=2048=0x800=0x10000>>SHIFT_2.\r\n    */\r\n   static readonly INDEX_2_OFFSET = 0;\r\n\r\n   /**\r\n    * The illegal-UTF-8 data block follows the ASCII block, at offset `128=0x80`.\r\n    * Used with linear access for single bytes 0..0xbf for simple error handling.\r\n    * Length `64=0x40`, not DATA_BLOCK_LENGTH.\r\n    */\r\n   static readonly BAD_UTF8_DATA_OFFSET = 0x80;\r\n\r\n   /**\r\n    * The start of non-linear-ASCII data blocks, at offset `192=0xc0`.\r\n    */\r\n   static readonly DATA_START_OFFSET = 0xc0;\r\n\r\n   /**\r\n    * The null data block.\r\n    * Length `64=0x40` even if DATA_BLOCK_LENGTH is smaller, to work with 6-bit trail bytes from 2-byte UTF-8.\r\n    */\r\n   static readonly DATA_NULL_OFFSET = this.DATA_START_OFFSET;\r\n\r\n   /**\r\n    * The start of allocated data blocks.\r\n    */\r\n   static readonly NEW_DATA_START_OFFSET = this.DATA_NULL_OFFSET + 0x40;\r\n\r\n   /**\r\n    * The start of data blocks for U+0800 and above.\r\n    * Below, compaction uses a block length of 64 for 2-byte UTF-8.\r\n    * From here on, compaction uses DATA_BLOCK_LENGTH.\r\n    * Data values for 0x780 code points beyond ASCII.\r\n    */\r\n   static readonly DATA_0800_OFFSET = this.NEW_DATA_START_OFFSET + 0x780;\r\n\r\n   /**\r\n    * Start with allocation of 16k data entries.\r\n    */\r\n   static readonly INITIAL_DATA_LENGTH = 1 << 14;\r\n\r\n   /**\r\n    * Grow about 8x each time.\r\n    */\r\n   static readonly MEDIUM_DATA_LENGTH = 1 << 17;\r\n\r\n   /**\r\n    * Maximum length of the runtime data array.\r\n    * Limited by 16-bit index values that are left-shifted by INDEX_SHIFT, and by uint16_t\r\n    * UTrie2Header.shiftedDataLength.\r\n    */\r\n   static readonly MAX_DATA_LENGTH_RUNTIME = 0xffff << Const.INDEX_SHIFT;\r\n\r\n   /**\r\n    *\r\n    */\r\n   static readonly INDEX_1_LENGTH = 0x110000 >> Const.SHIFT_1;\r\n\r\n   /**\r\n    * Maximum length of the build-time data array.\r\n    * One entry per `0x110000` code points, plus the illegal-UTF-8 block and the null block, plus values for the `0x400`\r\n    * surrogate code units.\r\n    */\r\n   static readonly MAX_DATA_LENGTH_BUILDTIME = 0x110000 + 0x40 + 0x40 + 0x400;\r\n\r\n   /**\r\n    * At build time, leave a gap in the index-2 table, at least as long as the maximum lengths of the 2-byte UTF-8\r\n    * index-2 table and the supplementary index-1 table.\r\n    * Round up to INDEX_2_BLOCK_LENGTH for proper compacting.\r\n    */\r\n   static readonly INDEX_GAP_OFFSET = Const.INDEX_2_BMP_LENGTH;\r\n   static readonly INDEX_GAP_LENGTH = ((Const.UTF8_2B_INDEX_2_LENGTH + Const.MAX_INDEX_1_LENGTH) +\r\n    Const.INDEX_2_MASK) & ~Const.INDEX_2_MASK;\r\n\r\n   /**\r\n    * Maximum length of the build-time index-2 array.\r\n    * Maximum number of Unicode code points (0x110000) shifted right by SHIFT_2,\r\n    * plus the part of the index-2 table for lead surrogate code points,\r\n    * plus the build-time index gap,\r\n    * plus the null index-2 block.\r\n    */\r\n   static readonly MAX_INDEX_2_LENGTH = (0x110000 >> Const.SHIFT_2) + Const.LSCP_INDEX_2_LENGTH +\r\n    this.INDEX_GAP_LENGTH + Const.INDEX_2_BLOCK_LENGTH;\r\n\r\n   /**\r\n    * The null index-2 block, following the gap in the index-2 table.\r\n    */\r\n   static readonly INDEX_2_NULL_OFFSET = this.INDEX_GAP_OFFSET + this.INDEX_GAP_LENGTH;\r\n\r\n   /**\r\n    * The start of allocated index-2 blocks.\r\n    */\r\n   static readonly INDEX_2_START_OFFSET = this.INDEX_2_NULL_OFFSET + Const.INDEX_2_BLOCK_LENGTH;\r\n\r\n   /**\r\n    * Maximum length of the runtime index array.\r\n    * Limited by its own 16-bit index values, and by uint16_t UTrie2Header.indexLength.\r\n    * The actual maximum length is lower, (0x110000>>SHIFT_2)+UTF8_2B_INDEX_2_LENGTH+MAX_INDEX_1_LENGTH.\r\n    */\r\n   static readonly MAX_INDEX_LENGTH = 0xffff;\r\n}\r\n","/**\r\n * Provides a helper utility to potentially swap a typed array to little endian.\r\n */\r\nexport class Swap32LE\r\n{\r\n   /**\r\n    * Swaps the given typed array as necessary to little endian as necessary. Uint8Array is assumed to have 32-bit data\r\n    * internally.\r\n    *\r\n    * @param {Uint8Array | Uint32Array} array - Array to potentially swap.\r\n    *\r\n    * @returns {Uint8Array | Uint32Array} Passed in array.\r\n    */\r\n   static swap(array: Uint8Array | Uint32Array)\r\n   {\r\n      /* c8 ignore next */\r\n      if (this.#isBigEndian) { this.#swap32(array); }\r\n\r\n      return array;\r\n   }\r\n\r\n   static #isBigEndian: boolean = (new Uint8Array(new Uint32Array([0x12345678]).buffer)[0] === 0x12);\r\n\r\n   /* c8 ignore next 6 */\r\n   static #swap(b, n, m)\r\n   {\r\n      const i = b[n];\r\n      b[n] = b[m];\r\n      b[m] = i;\r\n   }\r\n\r\n   /* c8 ignore next 10 */\r\n   static #swap32(array: Uint8Array | Uint32Array)\r\n   {\r\n      const len = array.length;\r\n\r\n      for (let i = 0; i < len; i += 4)\r\n      {\r\n         this.#swap(array, i, i + 3);\r\n         this.#swap(array, i + 1, i + 2);\r\n      }\r\n   }\r\n}\r\n","import { inflateSync }     from '#runtime/data/compress';\r\n\r\nimport { Const }           from './Constants';\r\nimport { Swap32LE }        from './Swap32LE';\r\n\r\nimport type {\r\n   UnicodeTrieParsedData,\r\n   UnicodeTrieRawData }    from './types';\r\n\r\n/**\r\n * Provides lookup in a pre-built UnicodeTrie data structure. Use {@link UnicodeTrieBuilder} for building /\r\n * serialization of a pre-built data structure.\r\n */\r\nexport class UnicodeTrie\r\n{\r\n   readonly #data: Uint32Array;\r\n\r\n   readonly #errorValue: number;\r\n\r\n   readonly #highStart: number;\r\n\r\n   /**\r\n    * @param {UnicodeTrieParsedData | UnicodeTrieRawData} data -\r\n    */\r\n   constructor(data: UnicodeTrieParsedData | UnicodeTrieRawData)\r\n   {\r\n      if (data instanceof Uint8Array)\r\n      {\r\n         // Is Node Buffer read binary format.\r\n         if (typeof data.readUInt32LE === 'function')\r\n         {\r\n            this.#highStart = data.readUInt32LE(0);\r\n            this.#errorValue = data.readUInt32LE(4);\r\n            data = data.slice(12);\r\n         }\r\n         else\r\n         {\r\n            const view = new DataView(data.buffer);\r\n            this.#highStart = view.getUint32(0, true);\r\n            this.#errorValue = view.getUint32(4, true);\r\n            data = data.subarray(12);\r\n         }\r\n\r\n         // Double inflate the actual trie data.\r\n         data = inflateSync(data);\r\n\r\n         // Swap bytes from little-endian.\r\n         Swap32LE.swap(data);\r\n\r\n         this.#data = new Uint32Array(data.buffer);\r\n      }\r\n      else\r\n      {\r\n         // pre-parsed data\r\n         ({ data: this.#data, highStart: this.#highStart, errorValue: this.#errorValue } = data);\r\n      }\r\n   }\r\n\r\n   /**\r\n    * @returns {Uint32Array} The data array.\r\n    */\r\n   get data(): Uint32Array { return this.#data; }\r\n\r\n   /**\r\n    * @returns {number} The error value.\r\n    */\r\n   get errorValue(): number { return this.#errorValue; }\r\n\r\n   /**\r\n    * @returns {number} The high start.\r\n    */\r\n   get highStart(): number { return this.#highStart; }\r\n\r\n   /**\r\n    * @param {number}   codePoint -\r\n    */\r\n   get(codePoint: number)\r\n   {\r\n      if ((codePoint < 0) || (codePoint > 0x10ffff)) { return this.#errorValue; }\r\n\r\n      let index;\r\n\r\n      if ((codePoint < 0xd800) || ((codePoint > 0xdbff) && (codePoint <= 0xffff)))\r\n      {\r\n         // Ordinary BMP code point, excluding leading surrogates.\r\n         // BMP uses a single level lookup.  BMP index starts at offset 0 in the index.\r\n         // data is stored in the index array itself.\r\n         index = (this.#data[codePoint >> Const.SHIFT_2] << Const.INDEX_SHIFT) + (codePoint & Const.DATA_MASK);\r\n\r\n         return this.#data[index];\r\n      }\r\n\r\n      if (codePoint <= 0xffff)\r\n      {\r\n         // Lead Surrogate Code Point.  A Separate index section is stored for\r\n         // lead surrogate code units and code points.\r\n         //   The main index has the code unit data.\r\n         //   For this function, we need the code point data.\r\n         index = (this.#data[Const.LSCP_INDEX_2_OFFSET +\r\n          ((codePoint - 0xd800) >> Const.SHIFT_2)] << Const.INDEX_SHIFT) +\r\n           (codePoint & Const.DATA_MASK);\r\n\r\n         return this.#data[index];\r\n      }\r\n\r\n      if (codePoint < this.#highStart)\r\n      {\r\n         // Supplemental code point, use two-level lookup.\r\n         index = this.#data[(Const.INDEX_1_OFFSET - Const.OMITTED_BMP_INDEX_1_LENGTH) + (codePoint >> Const.SHIFT_1)];\r\n\r\n         index = this.#data[index + ((codePoint >> Const.SHIFT_2) & Const.INDEX_2_MASK)];\r\n\r\n         index = (index << Const.INDEX_SHIFT) + (codePoint & Const.DATA_MASK);\r\n\r\n         return this.#data[index];\r\n      }\r\n\r\n      return this.#data[this.#data.length - Const.DATA_GRANULARITY];\r\n   }\r\n}\r\n","import { deflateSync }     from '#runtime/data/compress';\r\n\r\nimport { Const, ConstB }   from './Constants';\r\nimport { Swap32LE }        from './Swap32LE';\r\nimport { UnicodeTrie }     from './UnicodeTrie';\r\n\r\n/**\r\n * Builds the UnicodeTrie data structure with options to output to a Buffer or return an instance of UnicodeTrie.\r\n */\r\nexport class UnicodeTrieBuilder\r\n{\r\n   #data: Uint32Array;\r\n\r\n   #dataCapacity: number;\r\n\r\n   #dataLength: number;\r\n\r\n   #dataNullOffset: number;\r\n\r\n   readonly #errorValue: number;\r\n\r\n   #firstFreeBlock: number;\r\n\r\n   #highStart: number;\r\n\r\n   readonly #index1: Int32Array;\r\n\r\n   readonly #index2: Int32Array;\r\n\r\n   #index2Length: number;\r\n\r\n   #index2NullOffset: number;\r\n\r\n   readonly #initialValue: number;\r\n\r\n   #isCompacted: boolean;\r\n\r\n   readonly #map: Int32Array;\r\n\r\n   /**\r\n    * @param {number}   [initialValue] -\r\n    *\r\n    * @param {number}   [errorValue] -\r\n    */\r\n   constructor(initialValue?: number, errorValue?: number)\r\n   {\r\n      let i, j;\r\n\r\n      if (initialValue == null) { initialValue = 0; }\r\n\r\n      this.#initialValue = initialValue;\r\n\r\n      if (errorValue == null) { errorValue = 0; }\r\n\r\n      this.#errorValue = errorValue;\r\n      this.#index1 = new Int32Array(ConstB.INDEX_1_LENGTH);\r\n      this.#index2 = new Int32Array(ConstB.MAX_INDEX_2_LENGTH);\r\n      this.#highStart = 0x110000;\r\n\r\n      this.#data = new Uint32Array(ConstB.INITIAL_DATA_LENGTH);\r\n      this.#dataCapacity = ConstB.INITIAL_DATA_LENGTH;\r\n\r\n      this.#firstFreeBlock = 0;\r\n      this.#isCompacted = false;\r\n\r\n      // Multipurpose per-data-block table.\r\n      //\r\n      // Before compacting:\r\n      //\r\n      // Per-data-block reference counters/free-block list.\r\n      //  0: unused\r\n      // >0: reference counter (number of index-2 entries pointing here)\r\n      // <0: next free data block in free-block list\r\n      //\r\n      // While compacting:\r\n      //\r\n      // Map of adjusted indexes, used in compactData() and compactIndex2().\r\n      // Maps from original indexes to new ones.\r\n      this.#map = new Int32Array(ConstB.MAX_DATA_LENGTH_BUILDTIME >> Const.SHIFT_2);\r\n\r\n      for (i = 0; i < 0x80; i++) { this.#data[i] = this.#initialValue; }\r\n\r\n      for (i = i; i < 0xc0; i++) { this.#data[i] = this.#errorValue; }\r\n\r\n      for (i = ConstB.DATA_NULL_OFFSET; i < ConstB.NEW_DATA_START_OFFSET; i++) { this.#data[i] = this.#initialValue; }\r\n\r\n      this.#dataNullOffset = ConstB.DATA_NULL_OFFSET;\r\n      this.#dataLength = ConstB.NEW_DATA_START_OFFSET;\r\n\r\n      // set the index-2 indexes for the 2=0x80>>SHIFT_2 ASCII data blocks\r\n      i = 0;\r\n      for (j = 0; j < 0x80; j += Const.DATA_BLOCK_LENGTH)\r\n      {\r\n         this.#index2[i] = j;\r\n         this.#map[i++] = 1;\r\n      }\r\n\r\n      // reference counts for the bad-UTF-8-data block\r\n      for (j = j; j < 0xc0; j += Const.DATA_BLOCK_LENGTH) { this.#map[i++] = 0; }\r\n\r\n      // Reference counts for the null data block: all blocks except for the ASCII blocks.\r\n      // Plus 1 so that we don't drop this block during compaction.\r\n      // Plus as many as needed for lead surrogate code points.\r\n      // i==newTrie->dataNullOffset\r\n      this.#map[i++] = ((0x110000 >> Const.SHIFT_2) - (0x80 >> Const.SHIFT_2)) + 1 + Const.LSCP_INDEX_2_LENGTH;\r\n\r\n      j += Const.DATA_BLOCK_LENGTH;\r\n      for (j = j; j < ConstB.NEW_DATA_START_OFFSET; j += Const.DATA_BLOCK_LENGTH) { this.#map[i++] = 0; }\r\n\r\n      // set the remaining indexes in the BMP index-2 block\r\n      // to the null data block\r\n      for (i = 0x80 >> Const.SHIFT_2; i < Const.INDEX_2_BMP_LENGTH; i++) { this.#index2[i] = ConstB.DATA_NULL_OFFSET; }\r\n\r\n      // Fill the index gap with impossible values so that compaction\r\n      // does not overlap other index-2 blocks with the gap.\r\n      for (i = 0; i < ConstB.INDEX_GAP_LENGTH; i++) { this.#index2[ConstB.INDEX_GAP_OFFSET + i] = -1; }\r\n\r\n      // set the indexes in the null index-2 block\r\n      for (i = 0; i < Const.INDEX_2_BLOCK_LENGTH; i++)\r\n      {\r\n         this.#index2[ConstB.INDEX_2_NULL_OFFSET + i] = ConstB.DATA_NULL_OFFSET;\r\n      }\r\n\r\n      this.#index2NullOffset = ConstB.INDEX_2_NULL_OFFSET;\r\n      this.#index2Length = ConstB.INDEX_2_START_OFFSET;\r\n\r\n      // set the index-1 indexes for the linear index-2 block\r\n      j = 0;\r\n      for (i = 0; i < Const.OMITTED_BMP_INDEX_1_LENGTH; i++)\r\n      {\r\n         this.#index1[i] = j;\r\n         j += Const.INDEX_2_BLOCK_LENGTH;\r\n      }\r\n\r\n      // set the remaining index-1 indexes to the null index-2 block\r\n      for (i = i; i < ConstB.INDEX_1_LENGTH; i++) { this.#index1[i] = ConstB.INDEX_2_NULL_OFFSET; }\r\n\r\n      // Preallocate and reset data for U+0080..U+07ff,\r\n      // for 2-byte UTF-8 which will be compacted in 64-blocks\r\n      // even if DATA_BLOCK_LENGTH is smaller.\r\n      for (i = 0x80; i < 0x800; i += Const.DATA_BLOCK_LENGTH) { this.set(i, this.#initialValue); }\r\n   }\r\n\r\n   /**\r\n    * @returns {UnicodeTrie} The compacted and frozen data as a new UnicodeTrie instance.\r\n    */\r\n   freeze(): UnicodeTrie\r\n   {\r\n      let allIndexesLength, i;\r\n      if (!this.#isCompacted) { this.#compact(); }\r\n\r\n      if (this.#highStart <= 0x10000)\r\n      {\r\n         allIndexesLength = Const.INDEX_1_OFFSET;\r\n      }\r\n      else\r\n      {\r\n         allIndexesLength = this.#index2Length;\r\n      }\r\n\r\n      const dataMove = allIndexesLength;\r\n\r\n      // are indexLength and dataLength within limits?\r\n      if ((allIndexesLength > ConstB.MAX_INDEX_LENGTH) || // for unshifted indexLength\r\n       ((dataMove + this.#dataNullOffset) > 0xffff) || // for unshifted dataNullOffset\r\n       ((dataMove + ConstB.DATA_0800_OFFSET) > 0xffff) || // for unshifted 2-byte UTF-8 index-2 values\r\n       ((dataMove + this.#dataLength) > ConstB.MAX_DATA_LENGTH_RUNTIME))\r\n      { // for shiftedDataLength\r\n         throw new Error(\"Trie data is too large.\");\r\n      }\r\n\r\n      // calculate the sizes of, and allocate, the index and data arrays\r\n      const indexLength = allIndexesLength + this.#dataLength;\r\n      const data = new Uint32Array(indexLength);\r\n\r\n      // write the index-2 array values shifted right by INDEX_SHIFT, after adding dataMove\r\n      let destIdx = 0;\r\n      for (i = 0; i < Const.INDEX_2_BMP_LENGTH; i++)\r\n      {\r\n         data[destIdx++] = ((this.#index2[i] + dataMove) >> Const.INDEX_SHIFT);\r\n      }\r\n\r\n      // write UTF-8 2-byte index-2 values, not right-shifted\r\n      for (i = 0; i < 0xc2 - 0xc0; i++)\r\n      { // C0..C1\r\n         data[destIdx++] = (dataMove + ConstB.BAD_UTF8_DATA_OFFSET);\r\n      }\r\n\r\n      for (i = i; i < 0xe0 - 0xc0; i++)\r\n      { // C2..DF\r\n         data[destIdx++] = (dataMove + this.#index2[i << (6 - Const.SHIFT_2)]);\r\n      }\r\n\r\n      if (this.#highStart > 0x10000)\r\n      {\r\n         const index1Length = (this.#highStart - 0x10000) >> Const.SHIFT_1;\r\n         const index2Offset = Const.INDEX_2_BMP_LENGTH + Const.UTF8_2B_INDEX_2_LENGTH + index1Length;\r\n\r\n         // write 16-bit index-1 values for supplementary code points\r\n         for (i = 0; i < index1Length; i++)\r\n         {\r\n            data[destIdx++] = (ConstB.INDEX_2_OFFSET + this.#index1[i + Const.OMITTED_BMP_INDEX_1_LENGTH]);\r\n         }\r\n\r\n         // write the index-2 array values for supplementary code points,\r\n         // shifted right by INDEX_SHIFT, after adding dataMove\r\n         for (i = 0; i < this.#index2Length - index2Offset; i++)\r\n         {\r\n            data[destIdx++] = ((dataMove + this.#index2[index2Offset + i]) >> Const.INDEX_SHIFT);\r\n         }\r\n      }\r\n\r\n      // write 16-bit data values\r\n      for (i = 0; i < this.#dataLength; i++) { data[destIdx++] = this.#data[i]; }\r\n\r\n      return new UnicodeTrie({\r\n         data,\r\n         highStart: this.#highStart,\r\n         errorValue: this.#errorValue\r\n      });\r\n   }\r\n\r\n   /**\r\n    * @param {number}   codePoint - Code point to lookup.\r\n    *\r\n    * @param {boolean}  [fromLSCP=true] - Is this a lead surrogate code point.\r\n    */\r\n   get(codePoint: number, fromLSCP?: boolean)\r\n   {\r\n      let i2;\r\n      if (fromLSCP == null)\r\n      {\r\n         fromLSCP = true;\r\n      }\r\n      if ((codePoint < 0) || (codePoint > 0x10ffff))\r\n      {\r\n         return this.#errorValue;\r\n      }\r\n\r\n      if ((codePoint >= this.#highStart) && (!((codePoint >= 0xd800) && (codePoint < 0xdc00)) || fromLSCP))\r\n      {\r\n         return this.#data[this.#dataLength - Const.DATA_GRANULARITY];\r\n      }\r\n\r\n      if (((codePoint >= 0xd800) && (codePoint < 0xdc00)) && fromLSCP)\r\n      {\r\n         i2 = (Const.LSCP_INDEX_2_OFFSET - (0xd800 >> Const.SHIFT_2)) + (codePoint >> Const.SHIFT_2);\r\n      }\r\n      else\r\n      {\r\n         i2 = this.#index1[codePoint >> Const.SHIFT_1] + ((codePoint >> Const.SHIFT_2) & Const.INDEX_2_MASK);\r\n      }\r\n\r\n      const block = this.#index2[i2];\r\n      return this.#data[block + (codePoint & Const.DATA_MASK)];\r\n   }\r\n\r\n   /**\r\n    * @param {number}   codePoint - Code point to set.\r\n    *\r\n    * @param {value}    value - New value at code point.\r\n    */\r\n   set(codePoint: number, value: number)\r\n   {\r\n      if ((codePoint < 0) || (codePoint > 0x10ffff)) { throw new Error('Invalid code point'); }\r\n\r\n      if (this.#isCompacted) { throw new Error('Already compacted'); }\r\n\r\n      const block = this.#getDataBlock(codePoint, true);\r\n      this.#data[block + (codePoint & Const.DATA_MASK)] = value;\r\n      return this;\r\n   }\r\n\r\n   /**\r\n    * @param {number}   start - Start code point.\r\n    *\r\n    * @param {number}   end - End code point.\r\n    *\r\n    * @param {number}   value - Value to set.\r\n    *\r\n    * @param {boolean}  [overwrite] - Overwrite existing values.\r\n    */\r\n   setRange(start: number, end: number, value: number, overwrite?: boolean)\r\n   {\r\n      let block, repeatBlock;\r\n\r\n      if (overwrite == null) { overwrite = true; }\r\n\r\n      if ((start > 0x10ffff) || (end > 0x10ffff) || (start > end)) { throw new Error('Invalid code point'); }\r\n\r\n      if (this.#isCompacted) { throw new Error('Already compacted'); }\r\n\r\n      if (!overwrite && (value === this.#initialValue)) { return this; } // nothing to do\r\n\r\n      let limit = end + 1;\r\n      if ((start & Const.DATA_MASK) !== 0)\r\n      {\r\n         // set partial block at [start..following block boundary\r\n         block = this.#getDataBlock(start, true);\r\n\r\n         const nextStart = (start + Const.DATA_BLOCK_LENGTH) & ~Const.DATA_MASK;\r\n         if (nextStart <= limit)\r\n         {\r\n            this.#fillBlock(block, start & Const.DATA_MASK, Const.DATA_BLOCK_LENGTH, value, this.#initialValue,\r\n             overwrite);\r\n\r\n            start = nextStart;\r\n         }\r\n         else\r\n         {\r\n            this.#fillBlock(block, start & Const.DATA_MASK, limit & Const.DATA_MASK, value, this.#initialValue,\r\n             overwrite);\r\n\r\n            return this;\r\n         }\r\n      }\r\n\r\n      // number of positions in the last, partial block\r\n      const rest = limit & Const.DATA_MASK;\r\n\r\n      // round down limit to a block boundary\r\n      limit &= ~Const.DATA_MASK;\r\n\r\n      // iterate over all-value blocks\r\n      repeatBlock = value === this.#initialValue ? this.#dataNullOffset : -1;\r\n\r\n      while (start < limit)\r\n      {\r\n         let setRepeatBlock = false;\r\n\r\n         if ((value === this.#initialValue) && this.#isInNullBlock(start, true))\r\n         {\r\n            start += Const.DATA_BLOCK_LENGTH; // nothing to do\r\n            continue;\r\n         }\r\n\r\n         // get index value\r\n         let i2 = this.#getIndex2Block(start, true);\r\n         i2 += (start >> Const.SHIFT_2) & Const.INDEX_2_MASK;\r\n\r\n         block = this.#index2[i2];\r\n         if (this.#isWritableBlock(block))\r\n         {\r\n            // already allocated\r\n            if (overwrite && (block >= ConstB.DATA_0800_OFFSET))\r\n            {\r\n               // We overwrite all values, and it's not a\r\n               // protected (ASCII-linear or 2-byte UTF-8) block:\r\n               // replace with the repeatBlock.\r\n               setRepeatBlock = true;\r\n            }\r\n            else\r\n            {\r\n               // protected block: just write the values into this block\r\n               this.#fillBlock(block, 0, Const.DATA_BLOCK_LENGTH, value, this.#initialValue, overwrite);\r\n            }\r\n\r\n         }\r\n         else if ((this.#data[block] !== value) && (overwrite || (block === this.#dataNullOffset)))\r\n         {\r\n            // Set the repeatBlock instead of the null block or previous repeat block:\r\n            //\r\n            // If !isWritableBlock() then all entries in the block have the same value\r\n            // because it's the null block or a range block (the repeatBlock from a previous\r\n            // call to utrie2_setRange32()).\r\n            // No other blocks are used multiple times before compacting.\r\n            //\r\n            // The null block is the only non-writable block with the initialValue because\r\n            // of the repeatBlock initialization above. (If value==initialValue, then\r\n            // the repeatBlock will be the null data block.)\r\n            //\r\n            // We set our repeatBlock if the desired value differs from the block's value,\r\n            // and if we overwrite any data or if the data is all initial values\r\n            // (which is the same as the block being the null block, see above).\r\n            setRepeatBlock = true;\r\n         }\r\n\r\n         if (setRepeatBlock)\r\n         {\r\n            if (repeatBlock >= 0)\r\n            {\r\n               this.#setIndex2Entry(i2, repeatBlock);\r\n            }\r\n            else\r\n            {\r\n               // create and set and fill the repeatBlock\r\n               repeatBlock = this.#getDataBlock(start, true);\r\n               this.#writeBlock(repeatBlock, value);\r\n            }\r\n         }\r\n\r\n         start += Const.DATA_BLOCK_LENGTH;\r\n      }\r\n\r\n      if (rest > 0)\r\n      {\r\n         // set partial block at [last block boundary..limit\r\n         block = this.#getDataBlock(start, true);\r\n         this.#fillBlock(block, 0, rest, value, this.#initialValue, overwrite);\r\n      }\r\n\r\n      return this;\r\n   }\r\n\r\n   /**\r\n    * Generates a Node Buffer containing the serialized and compressed trie.\r\n    *\r\n    * Note: This only works on Node. Use toUint8Array otherwise.\r\n    *\r\n    * uint32_t highStart;\r\n    * uint32_t errorValue;\r\n    * uint32_t uncompressedDataLength;\r\n    * uint8_t trieData[dataLength];\r\n    *\r\n    * @returns {Buffer} A Node Buffer.\r\n    */\r\n   toBuffer(): Buffer\r\n   {\r\n      const trie = this.freeze();\r\n\r\n      const data = new Uint8Array(trie.data.buffer);\r\n\r\n      // Swap bytes to little-endian\r\n      Swap32LE.swap(data);\r\n\r\n      let compressed = deflateSync(data);\r\n\r\n      const buf = Buffer.alloc(compressed.length + 12);\r\n      buf.writeUInt32LE(trie.highStart, 0);\r\n      buf.writeUInt32LE(trie.errorValue, 4);\r\n      buf.writeUInt32LE(data.length, 8);\r\n\r\n      // Copy compressed data after header.\r\n      for (let i = 0; i < compressed.length; i++) { buf[i + 12] = compressed[i]; }\r\n\r\n      return buf;\r\n   }\r\n\r\n   /**\r\n    * Generates a packed Uint8Array containing the serialized and compressed trie.\r\n    *\r\n    * Note: This only works on Node. Use toUint8Array otherwise.\r\n    *\r\n    * uint32_t highStart;\r\n    * uint32_t errorValue;\r\n    * uint32_t uncompressedDataLength;\r\n    * uint8_t trieData[dataLength];\r\n    *\r\n    * @returns {Uint8Array} A packed Uint8Array.\r\n    */\r\n   toUint8Array(): Uint8Array\r\n   {\r\n      const trie = this.freeze();\r\n\r\n      const data = new Uint8Array(trie.data.buffer);\r\n\r\n      // Swap bytes to little-endian\r\n      Swap32LE.swap(data);\r\n\r\n      let compressed = deflateSync(data);\r\n\r\n      const output = new Uint8Array(compressed.length + 12);\r\n\r\n      const view = new DataView(output.buffer);\r\n      view.setUint32(0, trie.highStart, true);\r\n      view.setUint32(4, trie.errorValue, true);\r\n      view.setUint32(8, data.length, true);\r\n\r\n      output.set(compressed, 12);\r\n\r\n      return output;\r\n   }\r\n\r\n   // Internal -------------------------------------------------------------------------------------------------------\r\n\r\n   #allocDataBlock(copyBlock: number)\r\n   {\r\n      let newBlock;\r\n      if (this.#firstFreeBlock !== 0)\r\n      {\r\n         // get the first free block\r\n         newBlock = this.#firstFreeBlock;\r\n         this.#firstFreeBlock = -this.#map[newBlock >> Const.SHIFT_2];\r\n      }\r\n      else\r\n      {\r\n         // get a new block from the high end\r\n         newBlock = this.#dataLength;\r\n         const newTop = newBlock + Const.DATA_BLOCK_LENGTH;\r\n         if (newTop > this.#dataCapacity)\r\n         {\r\n            // out of memory in the data array\r\n            let capacity;\r\n            if (this.#dataCapacity < ConstB.MEDIUM_DATA_LENGTH)\r\n            {\r\n               capacity = ConstB.MEDIUM_DATA_LENGTH;\r\n            }\r\n            else if (this.#dataCapacity < ConstB.MAX_DATA_LENGTH_BUILDTIME)\r\n            {\r\n               capacity = ConstB.MAX_DATA_LENGTH_BUILDTIME;\r\n            }\r\n            else\r\n            {\r\n               // Should never occur.\r\n               // Either MAX_DATA_LENGTH_BUILDTIME is incorrect,\r\n               // or the code writes more values than should be possible.\r\n               throw new Error(\"Internal error in Trie2 creation.\");\r\n            }\r\n\r\n            const newData = new Uint32Array(capacity);\r\n            newData.set(this.#data.subarray(0, this.#dataLength));\r\n            this.#data = newData;\r\n            this.#dataCapacity = capacity;\r\n         }\r\n\r\n         this.#dataLength = newTop;\r\n      }\r\n\r\n      this.#data.set(this.#data.subarray(copyBlock, copyBlock + Const.DATA_BLOCK_LENGTH), newBlock);\r\n      this.#map[newBlock >> Const.SHIFT_2] = 0;\r\n      return newBlock;\r\n   }\r\n\r\n   #allocIndex2Block()\r\n   {\r\n      const newBlock = this.#index2Length;\r\n      const newTop = newBlock + Const.INDEX_2_BLOCK_LENGTH;\r\n      if (newTop > this.#index2.length)\r\n      {\r\n         // Should never occur.\r\n         // Either MAX_BUILD_TIME_INDEX_LENGTH is incorrect,\r\n         // or the code writes more values than should be possible.\r\n         throw new Error(\"Internal error in Trie2 creation.\");\r\n      }\r\n\r\n      this.#index2Length = newTop;\r\n\r\n      this.#index2.set(this.#index2.subarray(this.#index2NullOffset,\r\n       this.#index2NullOffset + Const.INDEX_2_BLOCK_LENGTH), newBlock);\r\n\r\n      return newBlock;\r\n   }\r\n\r\n   #compact()\r\n   {\r\n      // find highStart and round it up\r\n      let highValue = this.get(0x10ffff);\r\n      let highStart = this.#findHighStart(highValue);\r\n      highStart = (highStart + (ConstB.CP_PER_INDEX_1_ENTRY - 1)) & ~(ConstB.CP_PER_INDEX_1_ENTRY - 1);\r\n\r\n      if (highStart === 0x110000) { highValue = this.#errorValue; }\r\n\r\n      // Set trie->highStart only after utrie2_get32(trie, highStart).\r\n      // Otherwise utrie2_get32(trie, highStart) would try to read the highValue.\r\n      this.#highStart = highStart;\r\n      if (this.#highStart < 0x110000)\r\n      {\r\n         // Blank out [highStart..10ffff] to release associated data blocks.\r\n         const suppHighStart = this.#highStart <= 0x10000 ? 0x10000 : this.#highStart;\r\n         this.setRange(suppHighStart, 0x10ffff, this.#initialValue, true);\r\n      }\r\n\r\n      this.#compactData();\r\n      if (this.#highStart > 0x10000) { this.#compactIndex2(); }\r\n\r\n      // Store the highValue in the data array and round up the dataLength.\r\n      // Must be done after compactData() because that assumes that dataLength\r\n      // is a multiple of DATA_BLOCK_LENGTH.\r\n      this.#data[this.#dataLength++] = highValue;\r\n      while ((this.#dataLength & (Const.DATA_GRANULARITY - 1)) !== 0)\r\n      {\r\n         this.#data[this.#dataLength++] = this.#initialValue;\r\n      }\r\n\r\n      this.#isCompacted = true;\r\n   }\r\n\r\n   #compactData()\r\n   {\r\n      // do not compact linear-ASCII data\r\n      let newStart = ConstB.DATA_START_OFFSET;\r\n      let start = 0;\r\n      let i = 0;\r\n\r\n      while (start < newStart)\r\n      {\r\n         this.#map[i++] = start;\r\n         start += Const.DATA_BLOCK_LENGTH;\r\n      }\r\n\r\n      // Start with a block length of 64 for 2-byte UTF-8,\r\n      // then switch to DATA_BLOCK_LENGTH.\r\n      let blockLength = 64;\r\n      let blockCount = blockLength >> Const.SHIFT_2;\r\n      start = newStart;\r\n      while (start < this.#dataLength)\r\n      {\r\n         // start: index of first entry of current block\r\n         // newStart: index where the current block is to be moved\r\n         //           (right after current end of already-compacted data)\r\n         let mapIndex, movedStart;\r\n         if (start === ConstB.DATA_0800_OFFSET)\r\n         {\r\n            blockLength = Const.DATA_BLOCK_LENGTH;\r\n            blockCount = 1;\r\n         }\r\n\r\n         // skip blocks that are not used\r\n         if (this.#map[start >> Const.SHIFT_2] <= 0)\r\n         {\r\n            // advance start to the next block\r\n            start += blockLength;\r\n\r\n            // leave newStart with the previous block!\r\n            continue;\r\n         }\r\n\r\n         // search for an identical block\r\n         if ((movedStart = this.#findSameDataBlock(newStart, start, blockLength)) >= 0)\r\n         {\r\n            // found an identical block, set the other block's index value for the current block\r\n            mapIndex = start >> Const.SHIFT_2;\r\n            for (i = blockCount; i > 0; i--)\r\n            {\r\n               this.#map[mapIndex++] = movedStart;\r\n               movedStart += Const.DATA_BLOCK_LENGTH;\r\n            }\r\n\r\n            // advance start to the next block\r\n            start += blockLength;\r\n\r\n            // leave newStart with the previous block!\r\n            continue;\r\n         }\r\n\r\n         // see if the beginning of this block can be overlapped with the end of the previous block\r\n         // look for maximum overlap (modulo granularity) with the previous, adjacent block\r\n         let overlap = blockLength - Const.DATA_GRANULARITY;\r\n         while ((overlap > 0) && !this.#equalInt(this.#data, (newStart - overlap), start, overlap))\r\n         {\r\n            overlap -= Const.DATA_GRANULARITY;\r\n         }\r\n\r\n         if ((overlap > 0) || (newStart < start))\r\n         {\r\n            // some overlap, or just move the whole block\r\n            movedStart = newStart - overlap;\r\n            mapIndex = start >> Const.SHIFT_2;\r\n\r\n            for (i = blockCount; i > 0; i--)\r\n            {\r\n               this.#map[mapIndex++] = movedStart;\r\n               movedStart += Const.DATA_BLOCK_LENGTH;\r\n            }\r\n\r\n            // move the non-overlapping indexes to their new positions\r\n            start += overlap;\r\n            for (i = blockLength - overlap; i > 0; i--) { this.#data[newStart++] = this.#data[start++]; }\r\n         }\r\n         else\r\n         { // no overlap && newStart==start\r\n            mapIndex = start >> Const.SHIFT_2;\r\n            for (i = blockCount; i > 0; i--)\r\n            {\r\n               this.#map[mapIndex++] = start;\r\n               start += Const.DATA_BLOCK_LENGTH;\r\n            }\r\n\r\n            newStart = start;\r\n         }\r\n      }\r\n\r\n      // now adjust the index-2 table\r\n      i = 0;\r\n      while (i < this.#index2Length)\r\n      {\r\n         // Gap indexes are invalid (-1). Skip over the gap.\r\n         if (i === ConstB.INDEX_GAP_OFFSET) { i += ConstB.INDEX_GAP_LENGTH; }\r\n\r\n         this.#index2[i] = this.#map[this.#index2[i] >> Const.SHIFT_2];\r\n\r\n         ++i;\r\n      }\r\n\r\n      this.#dataNullOffset = this.#map[this.#dataNullOffset >> Const.SHIFT_2];\r\n\r\n      // ensure dataLength alignment\r\n      while ((newStart & (Const.DATA_GRANULARITY - 1)) !== 0) { this.#data[newStart++] = this.#initialValue; }\r\n\r\n      this.#dataLength = newStart;\r\n   }\r\n\r\n   #compactIndex2()\r\n   {\r\n      // do not compact linear-BMP index-2 blocks\r\n      let newStart = Const.INDEX_2_BMP_LENGTH;\r\n      let start = 0;\r\n      let i = 0;\r\n\r\n      while (start < newStart)\r\n      {\r\n         this.#map[i++] = start;\r\n         start += Const.INDEX_2_BLOCK_LENGTH;\r\n      }\r\n\r\n      // Reduce the index table gap to what will be needed at runtime.\r\n      newStart += Const.UTF8_2B_INDEX_2_LENGTH + ((this.#highStart - 0x10000) >> Const.SHIFT_1);\r\n      start = ConstB.INDEX_2_NULL_OFFSET;\r\n      while (start < this.#index2Length)\r\n      {\r\n         // start: index of first entry of current block\r\n         // newStart: index where the current block is to be moved\r\n         //           (right after current end of already-compacted data)\r\n\r\n         // search for an identical block\r\n         let movedStart;\r\n         if ((movedStart = this.#findSameIndex2Block(newStart, start)) >= 0)\r\n         {\r\n            // found an identical block, set the other block's index value for the current block\r\n            this.#map[start >> Const.SHIFT_1_2] = movedStart;\r\n\r\n            // advance start to the next block\r\n            start += Const.INDEX_2_BLOCK_LENGTH;\r\n\r\n            // leave newStart with the previous block!\r\n            continue;\r\n         }\r\n\r\n         // see if the beginning of this block can be overlapped with the end of the previous block\r\n         // look for maximum overlap with the previous, adjacent block\r\n         let overlap = Const.INDEX_2_BLOCK_LENGTH - 1;\r\n         while ((overlap > 0) && !this.#equalInt(this.#index2, (newStart - overlap), start, overlap)) { --overlap; }\r\n\r\n         if ((overlap > 0) || (newStart < start))\r\n         {\r\n            // some overlap, or just move the whole block\r\n            this.#map[start >> Const.SHIFT_1_2] = newStart - overlap;\r\n\r\n            // move the non-overlapping indexes to their new positions\r\n            start += overlap;\r\n            for (i = Const.INDEX_2_BLOCK_LENGTH - overlap; i > 0; i--)\r\n            {\r\n               this.#index2[newStart++] = this.#index2[start++];\r\n            }\r\n         }\r\n         else\r\n         { // no overlap && newStart==start\r\n            this.#map[start >> Const.SHIFT_1_2] = start;\r\n            start += Const.INDEX_2_BLOCK_LENGTH;\r\n            newStart = start;\r\n         }\r\n      }\r\n\r\n      // now adjust the index-1 table\r\n      for (i = 0; i < ConstB.INDEX_1_LENGTH; i++) { this.#index1[i] = this.#map[this.#index1[i] >> Const.SHIFT_1_2]; }\r\n\r\n      this.#index2NullOffset = this.#map[this.#index2NullOffset >> Const.SHIFT_1_2];\r\n\r\n      // Ensure data table alignment:\r\n      // Needs to be granularity-aligned for 16-bit trie\r\n      // (so that dataMove will be down-shiftable),\r\n      // and 2-aligned for uint32_t data.\r\n\r\n      // Arbitrary value: 0x3fffc not possible for real data.\r\n      while ((newStart & ((Const.DATA_GRANULARITY - 1) | 1)) !== 0)\r\n      {\r\n         this.#index2[newStart++] = 0x0000ffff << Const.INDEX_SHIFT;\r\n      }\r\n\r\n      this.#index2Length = newStart;\r\n   }\r\n\r\n   #equalInt(a: Int32Array | Uint32Array, s: number, t: number, length: number)\r\n   {\r\n      for (let i = 0; i < length; i++)\r\n      {\r\n         if (a[s + i] !== a[t + i]) { return false; }\r\n      }\r\n\r\n      return true;\r\n   }\r\n\r\n   #fillBlock(block: number, start: number, limit: number, value: number, initialValue: number, overwrite: boolean)\r\n   {\r\n      let i;\r\n      if (overwrite)\r\n      {\r\n         for (i = block + start; i < block + limit; i++) { this.#data[i] = value; }\r\n      }\r\n      else\r\n      {\r\n         for (i = block + start; i < block + limit; i++)\r\n         {\r\n            if (this.#data[i] === initialValue) { this.#data[i] = value; }\r\n         }\r\n      }\r\n   }\r\n\r\n   #findHighStart(highValue: number)\r\n   {\r\n      let prevBlock, prevI2Block;\r\n      const data32 = this.#data;\r\n      const initialValue = this.#initialValue;\r\n      const index2NullOffset = this.#index2NullOffset;\r\n      const nullBlock = this.#dataNullOffset;\r\n\r\n      // set variables for previous range\r\n      if (highValue === initialValue)\r\n      {\r\n         prevI2Block = index2NullOffset;\r\n         prevBlock = nullBlock;\r\n      }\r\n      else\r\n      {\r\n         prevI2Block = -1;\r\n         prevBlock = -1;\r\n      }\r\n\r\n      const prev = 0x110000;\r\n\r\n      // enumerate index-2 blocks\r\n      let i1 = ConstB.INDEX_1_LENGTH;\r\n      let c = prev;\r\n      while (c > 0)\r\n      {\r\n         const i2Block = this.#index1[--i1];\r\n         if (i2Block === prevI2Block)\r\n         {\r\n            // the index-2 block is the same as the previous one, and filled with highValue\r\n            c -= ConstB.CP_PER_INDEX_1_ENTRY;\r\n            continue;\r\n         }\r\n\r\n         prevI2Block = i2Block;\r\n         if (i2Block === index2NullOffset)\r\n         {\r\n            // this is the null index-2 block\r\n            if (highValue !== initialValue) { return c; }\r\n\r\n            c -= ConstB.CP_PER_INDEX_1_ENTRY;\r\n         }\r\n         else\r\n         {\r\n            // enumerate data blocks for one index-2 block\r\n            let i2 = Const.INDEX_2_BLOCK_LENGTH;\r\n            while (i2 > 0)\r\n            {\r\n               const block = this.#index2[i2Block + --i2];\r\n               if (block === prevBlock)\r\n               {\r\n                  // the block is the same as the previous one, and filled with highValue\r\n                  c -= Const.DATA_BLOCK_LENGTH;\r\n                  continue;\r\n               }\r\n\r\n               prevBlock = block;\r\n               if (block === nullBlock)\r\n               {\r\n                  // this is the null data block\r\n                  if (highValue !== initialValue) { return c; }\r\n\r\n                  c -= Const.DATA_BLOCK_LENGTH;\r\n               }\r\n               else\r\n               {\r\n                  let j = Const.DATA_BLOCK_LENGTH;\r\n                  while (j > 0)\r\n                  {\r\n                     const value = data32[block + --j];\r\n\r\n                     if (value !== highValue) { return c; }\r\n\r\n                     --c;\r\n                  }\r\n               }\r\n            }\r\n         }\r\n      }\r\n\r\n      // deliver last range\r\n      return 0;\r\n   }\r\n\r\n   #findSameDataBlock(dataLength: number, otherBlock: number, blockLength: number)\r\n   {\r\n      // ensure that we do not even partially get past dataLength\r\n      dataLength -= blockLength;\r\n      let block = 0;\r\n      while (block <= dataLength)\r\n      {\r\n         if (this.#equalInt(this.#data, block, otherBlock, blockLength)) { return block; }\r\n\r\n         block += Const.DATA_GRANULARITY;\r\n      }\r\n\r\n      return -1;\r\n   }\r\n\r\n   #findSameIndex2Block(index2Length: number, otherBlock: number)\r\n   {\r\n      // ensure that we do not even partially get past index2Length\r\n      index2Length -= Const.INDEX_2_BLOCK_LENGTH;\r\n      for (let block = 0; block <= index2Length; block++)\r\n      {\r\n         if (this.#equalInt(this.#index2, block, otherBlock, Const.INDEX_2_BLOCK_LENGTH)) { return block; }\r\n      }\r\n\r\n      return -1;\r\n   }\r\n\r\n   #getDataBlock(c: number, forLSCP: boolean)\r\n   {\r\n      let i2 = this.#getIndex2Block(c, forLSCP);\r\n      i2 += (c >> Const.SHIFT_2) & Const.INDEX_2_MASK;\r\n\r\n      const oldBlock = this.#index2[i2];\r\n      if (this.#isWritableBlock(oldBlock))\r\n      {\r\n         return oldBlock;\r\n      }\r\n\r\n      // allocate a new data block\r\n      const newBlock = this.#allocDataBlock(oldBlock);\r\n      this.#setIndex2Entry(i2, newBlock);\r\n      return newBlock;\r\n   }\r\n\r\n   #getIndex2Block(c: number, forLSCP: boolean)\r\n   {\r\n      if ((c >= 0xd800) && (c < 0xdc00) && forLSCP) { return Const.LSCP_INDEX_2_OFFSET; }\r\n\r\n      const i1 = c >> Const.SHIFT_1;\r\n      let i2 = this.#index1[i1];\r\n      if (i2 === this.#index2NullOffset)\r\n      {\r\n         i2 = this.#allocIndex2Block();\r\n         this.#index1[i1] = i2;\r\n      }\r\n\r\n      return i2;\r\n   }\r\n\r\n   #isInNullBlock(c: number, forLSCP: boolean)\r\n   {\r\n      let i2;\r\n      if (((c & 0xfffffc00) === 0xd800) && forLSCP)\r\n      {\r\n         i2 = (Const.LSCP_INDEX_2_OFFSET - (0xd800 >> Const.SHIFT_2)) + (c >> Const.SHIFT_2);\r\n      }\r\n      else\r\n      {\r\n         i2 = this.#index1[c >> Const.SHIFT_1] + ((c >> Const.SHIFT_2) & Const.INDEX_2_MASK);\r\n      }\r\n\r\n      const block = this.#index2[i2];\r\n      return block === this.#dataNullOffset;\r\n   }\r\n\r\n   #isWritableBlock(block: number)\r\n   {\r\n      return (block !== this.#dataNullOffset) && (this.#map[block >> Const.SHIFT_2] === 1);\r\n   }\r\n\r\n   #releaseDataBlock(block: number)\r\n   {\r\n      // put this block at the front of the free-block chain\r\n      this.#map[block >> Const.SHIFT_2] = -this.#firstFreeBlock;\r\n      this.#firstFreeBlock = block;\r\n   }\r\n\r\n   #setIndex2Entry(i2: number, block: number)\r\n   {\r\n      ++this.#map[block >> Const.SHIFT_2];  // increment first, in case block == oldBlock!\r\n      const oldBlock = this.#index2[i2];\r\n      if (--this.#map[oldBlock >> Const.SHIFT_2] === 0)\r\n      {\r\n         this.#releaseDataBlock(oldBlock);\r\n      }\r\n\r\n      this.#index2[i2] = block;\r\n   }\r\n\r\n   #writeBlock(block: number, value: number)\r\n   {\r\n      const limit = block + Const.DATA_BLOCK_LENGTH;\r\n      while (block < limit)\r\n      {\r\n         this.#data[block++] = value;\r\n      }\r\n   }\r\n}\r\n"],"names":[],"mappings":"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"}